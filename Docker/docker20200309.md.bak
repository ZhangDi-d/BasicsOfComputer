## Docker  学习2

### Docker 是什么？
我们在理解 Docker 之前，首先得先区分清楚两个概念，容器和虚拟机。

可能很多读者朋友都用过虚拟机，而对容器这个概念比较的陌生。我们用的传统虚拟机如 VMware ， VisualBox 之类的需要模拟整台机器包括硬件。

每台虚拟机都需要有自己的操作系统，虚拟机一旦被开启，预分配给它的资源将全部被占用。

每一台虚拟机包括应用，必要的二进制和库，以及一个完整的用户操作系统。

而容器技术是和我们的宿主机共享硬件资源及操作系统，可以实现资源的动态分配。

容器包含应用和其所有的依赖包，但是与其他容器共享内核。容器在宿主机操作系统中，在用户空间以分离的进程运行。

容器技术是实现操作系统虚拟化的一种途径，可以让您在资源受到隔离的进程中运行应用程序及其依赖关系。

通过使用容器，我们可以轻松打包应用程序的代码、配置和依赖关系，将其变成容易使用的构建块，从而实现环境一致性、运营效率、开发人员生产力和版本控制等诸多目标。

容器可以帮助保证应用程序快速、可靠、一致地部署，其间不受部署环境的影响。

容器还赋予我们对资源更多的精细化控制能力，让我们的基础设施效率更高。

通过下面这幅图，我们可以很直观的反映出这两者的区别所在：
![](https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQo2bm1I3ibcEzKBSRK9wjT6iaiaXUcs3AeDrn8vH43pospCYYqJnQUnAt88S2A3UTNTCicVZVzDpEAobA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)


Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。

而 Linux 容器是 Linux 发展出的另一种虚拟化技术，简单来讲， Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离，相当于是在正常进程的外面套了一个保护层。

对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。

Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。

程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker ，就不用担心环境问题。

总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。


### Docker 的优势

Docker 相比于传统虚拟化方式具有更多的优势：

Docker 启动快速属于秒级别。虚拟机通常需要几分钟去启动。

Docker 需要的资源更少。Docker 在操作系统级别进行虚拟化，Docker 容器和内核交互，几乎没有性能损耗，性能优于通过 Hypervisor 层与内核层的虚拟化。

Docker 更轻量。Docker 的架构可以共用一个内核与共享应用程序库，所占内存极小。同样的硬件环境，Docker 运行的镜像数远多于虚拟机数量，对系统的利用率非常高。

与虚拟机相比，Docker 隔离性更弱。Docker 属于进程之间的隔离，虚拟机可实现系统级别隔离。

安全性。Docker 的安全性也更弱，Docker 的租户 Root 和宿主机 Root 等同，一旦容器内的用户从普通用户权限提升为 Root 权限，它就直接具备了宿主机的 Root 权限，进而可进行无限制的操作。

虚拟机租户 Root 权限和宿主机的 Root 虚拟机权限是分离的，并且虚拟机利用如 Intel 的 VT-d 和 VT-x 的 ring-1 硬件隔离技术。

这种隔离技术可以防止虚拟机突破和彼此交互，而容器至今还没有任何形式的硬件隔离，这使得容器容易受到攻击。

可管理性。Docker 的集中化管理工具还不算成熟。各种虚拟化技术都有成熟的管理工具，例如 VMware vCenter 提供完备的虚拟机管理能力。

高可用和可恢复性。Docker 对业务的高可用支持是通过快速重新部署实现的。

虚拟化具备负载均衡，高可用，容错，迁移和数据保护等经过生产实践检验的成熟保障机制， VMware 可承诺虚拟机 99.999% 高可用，保证业务连续性。

快速创建、删除。虚拟化创建是分钟级别的，Docker 容器创建是秒级别的，Docker 的快速迭代性，决定了无论是开发、测试、部署都可以节约大量时间

交付、部署。虚拟机可以通过镜像实现环境交付的一致性，但镜像分发无法体系化。Docker 在 Dockerfile 中记录了容器构建过程，可在集群中实现快速分发和快速部署。

![](https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrfweSIticOjNciczkulkE1WOrliaH9VLurAGymUqqO0ibVZYPPeP2dtg3CkXybZby3cVTY5MznyZnF3A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)


### Docker 的三个基本概念

![](https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQo2bm1I3ibcEzKBSRK9wjT6iahBoJdlmIh6pO9zEpk1HVPK8f4ahOxYWIibgA6HPZZ5L9H2Wsq7yLVkQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

从上图我们可以看到，Docker 中包括三个基本的概念：

- Image(镜像)

- Container(容器)

- Repository(仓库)

#### Image(镜像)

那么镜像到底是什么呢？Docker 镜像可以看作是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。

镜像不包含任何动态数据，其内容在构建之后也不会被改变。镜像（Image）就是一堆只读层（read-only layer）的统一视角，也许这个定义有些难以理解，下面的这张图能够帮助读者理解镜像的定义：

![](https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQo2bm1I3ibcEzKBSRK9wjT6iavSxuic4UdGU1Yzd8wnwQqvWQYWeNcDPDibxoReNicccmIjsvlzVmj2N5w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

从左边我们看到了多个只读层，它们重叠在一起。除了最下面一层，其他层都会有一个指针指向下一层。这些层是 Docker 内部的实现细节，并且能够在主机的文件系统上访问到。

统一文件系统(Union File System)技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角。

这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。我们可以在图片的右边看到这个视角的形式。


#### Container(容器)

容器(Container)的定义和镜像(Image)几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。
![](https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQo2bm1I3ibcEzKBSRK9wjT6iauXXLx1C8UDwU1nD5u7BIHroWLZf6f3ibicWcCJ69ZX7EMZVZpCHa0jGA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

由于容器的定义并没有提及是否要运行容器，所以实际上，**容器 = 镜像 + 读写层。**

#### Repository(仓库)

Docker 仓库是集中存放镜像文件的场所。镜像构建完成后，可以很容易的在当前宿主上运行。

但是， 如果需要在其他服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry(仓库注册服务器)就是这样的服务。

有时候会把仓库(Repository)和仓库注册服务器(Registry)混为一谈，并不严格区分。

Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。

实际上，一个 Docker Registry 中可以包含多个仓库(Repository)，每个仓库可以包含多个标签(Tag)，每个标签对应着一个镜像。

所以说，镜像仓库是 Docker 用来集中存放镜像文件的地方，类似于我们之前常用的代码仓库。

通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本 。

我们可以通过<仓库名>:<标签>的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 Latest 作为默认标签。

仓库又可以分为两种形式：

- Public(公有仓库)

- Private(私有仓库)

Docker Registry 公有仓库是开放给用户使用、允许用户管理镜像的 Registry 服务。

一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。

除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。

当用户创建了自己的镜像之后就可以使用 Push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 Pull 下来就可以了。

我们主要把 Docker 的一些常见概念如 Image，Container，Repository 做了详细的阐述，也从传统虚拟化方式的角度阐述了 Docker 的优势。


我们从下图可以直观地看到 Docker 的架构：

![](![在这里插入图片描述](https://img-blog.csdnimg.cn/20200304154231794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZWxsZXlMaXR0bGVoZXJv,size_16,color_FFFFFF,t_70))

Docker 使用 C/S 结构，即客户端/服务器体系结构。Docker 客户端与 Docker 服务器进行交互，Docker服务端负责构建、运行和分发 Docker 镜像。

Docker 客户端和服务端可以运行在一台机器上，也可以通过 RESTful 、 Stock 或网络接口与远程 Docker 服务端进行通信。

![](![在这里插入图片描述](https://img-blog.csdnimg.cn/20200304154239301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZWxsZXlMaXR0bGVoZXJv,size_16,color_FFFFFF,t_70))

这张图展示了 Docker 客户端、服务端和 Docker 仓库（即 Docker Hub 和 Docker Cloud ），默认情况下 Docker 会在 Docker 中央仓库寻找镜像文件。

这种利用仓库管理镜像的设计理念类似于 Git ，当然这个仓库是可以通过修改配置来指定的，甚至我们可以创建我们自己的私有仓库。

### Docker 的安装和使用

Docker 的安装和使用有一些前提条件，主要体现在体系架构和内核的支持上。

对于体系架构，除了 Docker 一开始就支持的 X86-64 ，其他体系架构的支持则一直在不断地完善和推进中。

Docker 分为 CE 和 EE 两大版本。CE 即社区版，免费支持周期 7 个月；EE 即企业版，强调安全，付费使用，支持周期 24 个月。

我们在安装前可以参看官方文档获取最新的 Docker 支持情况，官方文档在这里：

https://docs.docker.com/install/

Docker 对于内核支持的功能，即内核的配置选项也有一定的要求(比如必须开启 Cgroup 和 Namespace 相关选项，以及其他的网络和存储驱动等)。

Docker 源码中提供了一个检测脚本来检测和指导内核的配置，脚本链接在这里：

https://raw.githubusercontent.com/docker/docker/master/contrib/check-config.sh

在满足前提条件后，安装就变得非常的简单了。

Docker CE 的安装请参考官方文档：

MacOS：https://docs.docker.com/docker-for-mac/install/

Windows：https://docs.docker.com/docker-for-windows/install/

Ubuntu：https://docs.docker.com/install/linux/docker-ce/ubuntu/

Debian：https://docs.docker.com/install/linux/docker-ce/debian/

CentOS：https://docs.docker.com/install/linux/docker-ce/centos/

Fedora：https://docs.docker.com/install/linux/docker-ce/fedora/

其他 Linux 发行版：https://docs.docker.com/install/linux/docker-ce/binaries/

#### 安装 Docker

Docker 软件包已经包括在默认的 CentOS-Extras 软件源里。因此想要安装 Docker，只需要运行下面的 yum 命令：
```
$ sudo yum install docker
```

当然在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这套脚本安装：
```
curl -fsSL get.docker.com -o get-docker.sh
sh get-docker.sh
```

具体可以参看 docker-install 的脚本：

https://github.com/docker/docker-install


执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的 Edge 版本安装在系统中。

安装完成后，运行下面的命令，验证是否安装成功：
```
docker version 

```

启动 Docker-CE：
```
$ sudo systemctl enable docker$ sudo systemctl start docker

```


#### Docker 的简单运用 Hello World

我们通过最简单的 Image 文件 Hello World，感受一下 Docker 的魅力吧！

我们直接运行下面的命令，将名为 hello-world 的 image 文件从仓库抓取到本地：
```
docker pull library/hello-world

```

docker pull images 是抓取 image 文件，library/hello-world 是 image 文件在仓库里面的位置，其中 library 是 image 文件所在的组，hello-world 是 image 文件的名字。


![在这里插入图片描述](https://img-blog.csdnimg.cn/20200304154355601.png)


抓取成功以后，就可以在本机看到这个 image 文件了：
```
docker images
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200304154603292.png)


现在，我们可以运行 hello-world 这个 image 文件：
```
docker run hello-world
```

我们可以看到如下结果:

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200304154734992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZWxsZXlMaXR0bGVoZXJv,size_16,color_FFFFFF,t_70)



输出这段提示以后，hello world 就会停止运行，容器自动终止。有些容器不会自动终止，因为提供的是服务，比如 MySQL 镜像等。



### 配置镜像加速器

http://www.itmuch.com/docker/03-docker-mirror/

####  常见命令

systemctl命令是系统服务管理器指令

启动docker：
systemctl start docker

停止docker：
systemctl stop docker

重启docker：
systemctl restart docker

查看docker状态：
systemctl status docker

开机启动：
systemctl enable docker

查看docker概要信息
docker info


### Docker镜像常用命令

#### 搜索镜像
可使用docker search 命令搜索存放在Docker Hub中的镜像。

命令格式：
```
docker search [OPTIONS] TERM
```

参数：

|Name, shorthand|	Default	|Description|
|:---|:---|:---|
|--automated	|false	|只列出自动构建的镜像|
|--filter, -f|	|	根据指定条件过滤结果|
|--limit|	25|	搜索结果的最大条数|
|--no-trunc	|false	|不截断输出，显示完整的输出|
|--stars, -s|	0|	只展示Star不低于该数值的结果 (废弃)|

|11|11|
|:--|:--|
|1|1|


示例:
```
docker search -filter=stars=10 java

```

#### 下载镜像[重要]

```
docker pull [OPTIONS] NAME[:TAG|@DIGEST]

```

参数：
|Name, shorthand|Default|Description|
|:---|:---|:---|
|--all-tags, -a|	false|	下载所有标签的镜像|
|--disable-content-trust |	true	|忽略镜像的校验|


示例:
```
docker pull reg.itmuch.com/java:7

```

#### 列出镜像[重要]

```
docker images
```

命令格式：
```
docker images [OPTIONS] [REPOSITORY[:TAG]]
```

参数：

|Name, shorthand|	Default	|Description|
|:---|:---|:---|
|--all, -a	|false	|列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）|
|--digests|	false	|显示摘要信息|
|--filter, -f|		|显示满足条件的镜像|
|--format|		通过Go语言模板文件展示镜像|
|--no-trunc|	false|	不截断输出，显示完整的镜像信息|
|--quiet, -q|	false|	只显示镜像ID|


示例：
```
docker images
docker images java
docker images java:8
docker images --digests
docker images --filter "dangling=true"   # 展示虚悬镜像
```



#### 删除本地镜像[重要]

命令格式：
```
docker rmi [OPTIONS] IMAGE [IMAGE...]
```


参数：

|Name, shorthand|	Default	|Description|
|:---|:---|:---|
|--force, -f|	false	|强制删除|
|--no-prune	|false|	不移除该镜像的过程镜像，默认移除|

例1：删除指定名称的镜像。
```
docker rmi hello-world
```
表示删除hello-world这个镜像。

例2：删除所有镜像。
```
docker rmi -f $(docker images)
```
-f参数表示强制删除。


#### 保存镜像
使用docker save 即可保存镜像。

命令格式：
```
docker save [OPTIONS] IMAGE [IMAGE...]
```
参数：

|Name, shorthand|	Default	|Description|
|:---|:---|:---|
|--output, -o|	|	Write to a file, instead of STDOUT|

例1：
```
docker save busybox > busybox.tar
docker save --output busybox.tar busybox
```

### 加载镜像

使用docer load 命令即可加载镜像。

命令格式：
```
docker load [OPTIONS]
```

参数：

|Name, shorthand|	Default|	Description|
|:--|:--|:--|
|--input, -i|	|	从文件加载而非STDIN|
|--quiet, -q|	false|	静默加载|



#### 构建镜像[重要]
通过Dockerfile构建镜像。

命令格式：
```
docker build [OPTIONS] PATH | URL | -
```

参数：
http://www.itmuch.com/docker/04-docker-command-images/




















