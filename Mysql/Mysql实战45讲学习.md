## Mysql 实战45讲学习

### 01 一条SQL查询语句是如何执行的？

#### MySQL的基本架构示意图

![在这里插入图片描述](https://img-blog.csdnimg.cn/2020011914092863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZWxsZXlMaXR0bGVoZXJv,size_16,color_FFFFFF,t_70)

大体来说， MySQL可以分为Server层和存储引擎层两部分。

Server层包括连接器、 查询缓存、 分析器、 优化器、 执行器等.涵盖MySQL的大多数核心服务
功能， 以及所有的内置函数（ 如日期、 时间、 数学和加密函数等） ， 所有跨存储引擎的功能都在
这一层实现， 比如存储过程、 触发器、 视图等


#### 连接器
第一步， 你会先连接到这个数据库上， 这时候接待你的就是连接器。 连接器负责跟客户端建立连
接、 获取权限、 维持和管理连接。 连接命令一般是这么写的：

```
mysql -h$ip -P$port -u$user -p
```

#### 查询缓存
连接建立完成后， 你就可以执行select语句了。 执行逻辑就会来到第二步： 查询缓存。

但是大多数情况下我会建议你不要使用查询缓存， 为什么呢？ 因为查询缓存往往弊大于
利。

需要注意的是， MySQL 8.0版本直接将查询缓存的整块功能删掉了， 也就是说8.0开始彻底没有
这个功能了。

#### 分析器
词法分析 从你输入的"select"这个关键字识别出来， 这是一个查询语句

语法分析 You have an error in your SQL syntax

#### 优化器

优化器是在表里面有多个索引的时候， 决定使用哪个索引； 或者在一个语句有多表关联（ join）
的时候， 决定各个表的连接顺序。

#### 执行器

MySQL通过分析器知道了你要做什么， 通过优化器知道了该怎么做， 于是就进入了执行器阶
段， 开始执行语句。

开始执行的时候， 要先判断一下你对这个表T有没有执行查询的权限， 如果没有， 就会返回没有
权限的错误， 如
```
ERROR 1142 (42000): SELECT command denied to user 'b'@'localhost' for table 'T'
```

如果有权限， 就打开表继续执行。 打开表的时候， 执行器就会根据表的引擎定义， 去使用这个引
擎提供的接口。

比如我们这个例子中的表T中， ID字段没有索引， 那么执行器的执行流程是这样的：

1. **调用InnoDB引擎接口**取这个表的第一行， 判断ID值是不是10， 如果不是则跳过， 如果是则
将这行存在结果集中；
2. 调用引擎接口取“下一行”， 重复相同的判断逻辑， 直到取到这个表的最后一行。
3. 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。
至此， 这个语句就执行完成了。

对于有索引的表， 执行的逻辑也差不多。 第一次调用的是“取满足条件的第一行”这个接口， 之后
循环取“满足条件的下一行”这个接口， 这些接口都是引擎中已经定义好的。

慢查询日志中可看到一个rows_examined的字段， 表示这个语句执行过程中扫描了多少行。 



### 02 日志系统： 一条SQL更新语句是如何执行的？

建表:
```
 mysql> create table T(ID int primary key, c int);
```

更新语句:
```
 mysql> update T set c=c+1 where ID=2;
```

引出 -> redo log（ 重做日志） 和 binlog（ 归档日志）;

#### 重要的日志模块： redo log

粉板和账本配合的整个过程， 其实就是MySQL里经常说到的WAL技术， **WAL的全称是WriteAhead Logging，** 它的关键点就是先写日志， 再写磁盘， 也就是先写粉板， 等不忙的时候再写账
本.  <font color=blue >先写日志,再写磁盘 </font>

具体来说， 当有一条记录需要更新的时候， InnoDB引擎就会先把记录写到redo log（ 粉板） 里
面， 并更新内存， 这个时候更新就算完成了。 同时， InnoDB引擎会在适当的时候， 将这个操作
记录更新到磁盘里面， 而这个更新往往是在系统比较空闲的时候做， 这就像打烊以后掌柜做的
事.


InnoDB的redo log是固定大小的， 比如可以配置为一组4个文件， 每个文件的大小是
1GB， 那么这块“粉板”总共就可以记录4GB的操作。 从头开始写， **写到末尾就又回到开头循环**
写， 如下面这个图所示

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200117142818946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZWxsZXlMaXR0bGVoZXJv,size_16,color_FFFFFF,t_70)


有了redo log， InnoDB就可以保证即使数据库发生异常重启， 之前提交的记录都不会丢失， 这个
能力称为crash-safe。

#### 重要的日志模块： binlog

MySQL整体来看， 其实就有两块： 一块是Server层， 它主要做的是MySQL功能
层面的事情； 还有一块是引擎层， 负责存储相关的具体事宜。 上面我们聊到的粉板redo log是
InnoDB引擎特有的日志， 而Server层也有自己的日志， 称为binlog（ 归档日志） 。

<font color=blue>redo log -->InnoDB特有 </font>
<font color=blue>bin log -->server层 </font>

**为什么会有两份日志?**

因为最开始MySQL里并没有InnoDB引擎。 MySQL自带的引擎是MyISAM， 但是MyISAM没有
crash-safe的能力， binlog日志只能用于归档。 而InnoDB是另一个公司以插件形式引入MySQL
的， 既然只依靠binlog是没有crash-safe能力的， 所以InnoDB使用另外一套日志系统— — 也就是redo log来实现crash-safe能力.

**redo log和bin log 日志有以下三点不同**:

1. redo log是InnoDB引擎特有的； binlog是MySQL的Server层实现的， 所有引擎都可以使用。
2. redo log是物理日志， 记录的是“在某个数据页上做了什么修改”； binlog是逻辑日志， 记录的
是这个语句的原始逻辑， 比如“给ID=2这一行的c字段加1 ”。
3. redo log是循环写的， 空间固定会用完； binlog是可以追加写入的。 “追加写”是指binlog文件
写到一定大小后会切换到下一个， 并不会覆盖以前的日志。

**InnoDB引擎在执行下面这个update语句时的内部流程。**

语句:
```
 mysql> update T set c=c+1 where ID=2;
```

1. 执行器先找引擎取ID=2这一行。 ID是主键， 引擎直接用树搜索找到这一行。 如果ID=2这一行所在的数据页本来就在内存中， 就直接返回给执行器； 否则， 需要先从磁盘读入内存， 然后再返回。
2. 执行器拿到引擎给的行数据， 把这个值加上1， 比如原来是N， 现在就是N+1， 得到新的一行数据， 再调用引擎接口写入这行新数据。
3. 引擎将这行新数据更新到内存中， 同时将这个更新操作记录到redo log里面， 此时**redo log处于prepare状态**。 然后告知执行器执行完成了， 随时可以提交事务。
4. 执行器生成这个操作的binlog， 并把binlog写入磁盘。
5. 执行器调用引擎的提交事务接口， 引擎把刚刚写入的redo log改成提交（ commit） 状态， 更新完成。

**update语句的执行流程图:**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200117155006100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZWxsZXlMaXR0bGVoZXJv,size_16,color_FFFFFF,t_70)


 最后三步看上去有点“绕”， 将redo log的写入拆成了两个步骤： prepare和 commit， **这就是"两阶段提交".**


#### 两阶段提交

**为什么必须有“两阶段提交”呢？ 这是为了让两份日志之间的逻辑一致。** 要说明这个问题， 我们得
从文章开头的那个问题说起： 怎样让数据库恢复到半个月内任意一秒的状态？

binlog会记录所有的逻辑操作， 并且是采用“追加写”的形式。 如果你的DBA承
诺说半个月内可以恢复， 那么备份系统中一定会保存最近半个月的所有binlog， 同时系统会定期
做整库备份。 这里的“定期”取决于系统的重要性， 可以是一天一备， 也可以是一周一备。


**为什么日志需要“两阶段提交”。 这里不妨用反证法来进行解释:**

由于redo log和binlog是两个独立的逻辑， 如果不用两阶段提交， 要么就是先写完redo log再写
binlog， 或者采用反过来的顺序。 我们看看这两种方式会有什么问题。


1. **先写redo log后写binlog。** 假设在redo log写完， binlog还没有写完的时候， MySQL进程异
常重启。 由于我们前面说过的， redo log写完之后， 系统即使崩溃， 仍然能够把数据恢复回
来， 所以恢复后这一行c的值是1。
但是由于binlog没写完就crash了， 这时候binlog里面就没有记录这个语句。 因此， 之后备份
日志的时候， 存起来的binlog里面就没有这条语句。
然后你会发现， 如果需要用这个binlog来恢复临时库的话， 由于这个语句的binlog丢失， 这
个临时库就会少了这一次更新， 恢复出来的这一行c的值就是0， 与原库的值不同。

2. **先写binlog后写redo log。** 如果在binlog写完之后crash， 由于redo log还没写， 崩溃恢复以
后这个事务无效， 所以这一行c的值是0。 但是binlog里面已经记录了“把c从0改成1”这个日
志。 所以， 在之后用binlog来恢复的时候就多了一个事务出来， 恢复出来的这一行c的值就是
1， 与原库的值不同。

如果不使用“两阶段提交”， 那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致.简单说， redo log和binlog都可以用于表示事务的提交状态， 而两阶段提交就是让这两个状态保
持逻辑上的一致.


redo log用于保证crash-safe能力。 <font color=blue>innodb_flush_log_at_trx_commit这个参数设置成1的时候，表示每次事务的redo log都直接持久化到磁盘。</font> 这个参数我建议你设置成1， 这样可以保证
MySQL异常重启之后数据不丢失。

<font color=blue>sync_binlog这个参数设置成1的时候， 表示每次事务的binlog都持久化到磁盘。</font> 这个参数我也建
议你设置成1， 这样可以保证MySQL异常重启之后binlog不丢失。


### 03 事务隔离： 为什么你改了我还看不见？

事务就是要保证一组数据库操作， 要么全部成功， 要么全部失败。 在MySQL中， 事务支持是在引擎层实现的。

比如MySQL原生的MyISAM引擎就不支持事务， 这也是MyISAM被InnoDB取代的重要原因之一。


#### 隔离性与隔离级别

ACID（ Atomicity、 Consistency、 Isolation、 Durability， 即原子性、 一致性、 隔离性、 持久性） 

个事务同时执行可能引发:  脏读（ dirtyread） 、 不可重复读（ non-repeatable read） 、 幻读（ phantom read）

SQL标准的事务隔离级别包括： 读未提交（ read uncommitted） 、读提交（ read committed） 、可重复读（ repeatable read） 和串行化（ serializable ）


- 读未提交 是指， 一个事务还没提交时， 它做的变更就能被别的事务看到。
- 读已提交 是指， 一个事务提交之后， 它做的变更才会被其他事务看到。
- 可重复读 是指， 一个事务执行过程中看到的数据， 总是跟这个事务在启动时看到的数据是一致的。 当然在可重复读隔离级别下， 未提交变更对其他事务也是不可见的。
- 串行化， 顾名思义是对于同一行记录， “写”会加“写锁”， “读”会加“读锁”。 当出现读写锁冲突的时候， 后访问的事务必须等前一个事务执行完成， 才能继续执行。


#### 读提交和可重复读理解
其中“读提交”和“可重复读”比较难理解， 所以我用一个例子说明这几种隔离级别。 假设数据表T中只有一列， 其中一行的值为1， 下面是按照时间顺序执行两个事务的行为。
```
mysql> create table T(c int) engine=InnoDB;
insert into T(c) values(1);
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/2020011916560325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZWxsZXlMaXR0bGVoZXJv,size_16,color_FFFFFF,t_70)


我们来看看在不同的隔离级别下， 事务A会有哪些不同的返回结果， 也就是**图里面V1、 V2、 V3的返回值分别是什么。**

- 若隔离级别是“读未提交”， 则V1的值就是2。 这时候事务B虽然还没有提交， 但是结果已经被A看到了。 因此， V2、 V3也都是2。

- 若隔离级别是“读提交”， 则V1是1， V2的值是2。 事务B的更新在提交后才能被A看到。 所以，V3的值也是2。

- 若隔离级别是“可重复读”， 则V1、 V2是1， V3是2。 之所以V2还是1， **可重复读->>遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。**

- 若隔离级别是“串行化”， 则在事务B执行“将1改成2”的时候， 会被锁住。 直到事务A提交后， 事务B才可以继续执行。 所以从A的角度看， V1、 V2值是1， V3的值是2。


在实现上， 数据库里面会创建一个视图， 访问的时候以视图的逻辑结果为准。 <font color=blue>在“可重复读”隔离级别下， 这个视图是在事务启动时创建的， 整个事务存在期间都用这个视图。在“读提交”隔离级别下， 这个视图是在每个SQL语句开始执行的时候创建的。</font> 
 
这里需要注意的是， “读未提交”隔离级别下直接返回记录上的最新值， 没有视图概念； 而“串行化”隔离级别下直接用加锁的方式来避免并行访问。

<font color=blue>参数transaction-isolation的值设置READ-COMMITTED </font>


#### 什么时候需要“可重复读”的场景呢？ 

我们来看一个数据校对逻辑的案例。

假设你在管理一个个人银行账户表。 一个表存了每个月月底的余额， 一个表存了账单明细。 这时候你要做数据校对， 也就是判断上个月的余额和当前余额的差额， 是否与本月的账单明细一致。你一定希望在校对过程中， 即使有用户发生了一笔新的交易， 也不影响你的校对结果。

这时候使用“可重复读”隔离级别就很方便。 事务启动时的视图可以认为是静态的， 不受其他事务更新的影响.


#### 事务隔离的实现

理解了事务的隔离级别， 我们再来看看事务隔离具体是怎么实现的。 这里我们展开说明“可重复读”。

在MySQL中， 实际上每条记录在更新的时候都会同时记录一条回滚操作。 记录上的最新值， 通过回滚操作， 都可以得到前一个状态的值。

假设一个值从1被按顺序改成了2、 3、 4， 在回滚日志里面就会有类似下面的记录。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200119172256451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZWxsZXlMaXR0bGVoZXJv,size_16,color_FFFFFF,t_70)


当前值是4， 但是在查询这条记录的时候， 不同时刻启动的事务会有不同的read-view。 如图中看
到的， 在视图A、 B、 C里面， 这一个记录的值分别是1、 2、 4， 同一条记录在系统中可以存在多
个版本， 就是**数据库的多版本并发控制（ MVCC）** 。 对于read-view A， 要得到1， 就必须将当前
值依次执行图中所有的回滚操作得到.


你一定会问， 回滚日志总不能一直保留吧， 什么时候删除呢？ 答案是， 在不需要的时候才删除。
也就是说， 系统会判断， 当没有事务再需要用到这些回滚日志时， 回滚日志会被删除。


**为什么建议你尽量不要使用长事务:**

- 长事务意味着系统里面会存在很老的事务视图。 由于这些事务随时可能访问数据库里面的任何数
据， 所以这个事务提交之前， 数据库里面它可能用到的回滚记录都必须保留， 这就会导致大量占
用存储空间。
- 除了对回滚段的影响， 长事务还占用锁资源， 也可能拖垮整个库.


#### 事务的启动方式

MySQL的事务启动方式有以下几种：

1. 显式启动事务语句， begin 或 start transaction。 配套的提交语句是commit， 回滚语句是
rollback。
2. **set autocommit=0， 这个命令会将这个线程的自动提交关掉。** 意味着如果你只执行一个
select语句， 这个事务就启动了， 而且并不会自动提交。 这个事务持续存在直到你主动执行
commit 或 rollback 语句， 或者断开连接。

<font color=blue>建议总是使用set autocommit=1, 通过显式语句的方式来启动事务。</font>


#### 查询长事务的语句
```
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
```


### 04 深入浅出索引（ 上）

> 索引的出现其实就是为了提高数据查询的效率， 就像书的目录一样。 

#### 索引的常见模型

##### 哈希表:

哈希表是一种以键-值（ key-value） 存储数据的结构， 我们只要输入待查找的值即key， 就可以找到其对应的值即Value。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200120100230557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZWxsZXlMaXR0bGVoZXJv,size_16,color_FFFFFF,t_70)

多个Key经过hash,得到同一个值时,拉出一个链表.

图中**四个ID_card_n的值并不是递增的**， 这样做的好处是增加新的User时速度会很快， 只需要往后追加。 但缺点是， 因为不是有序的， 所以哈希索引做区间查询的速度是很慢的。

新增快,区间查询慢,相当于要在区间段做全表扫描.  **哈希表这种结构适用于只有等值查询的场景.**

##### 有序数组:

有序数组在等值查询和范围查询场景中的性能就都非常优秀。

上面这个根据身份证号查名字的例子， 如果我们使用有序数组来实现的话， 示意图如下所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200120100649400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZWxsZXlMaXR0bGVoZXJv,size_16,color_FFFFFF,t_70)

假设身份证号没有重复， 这个数组就是按照身份证号递增的顺序保存的。 这时候如果你要查ID_card_n2对应的名字， 用二分法就可以快速得到， 这个时间复杂度是O(log(N))。

在需要更新数据的时候就麻烦了， 你往中间插入一个记录就必须得挪动后面所有的记录， 成本太高。

有序数组索引只适用于静态存储引擎.
 
 
##### 二叉搜索树:

二叉搜索树的特点是： 每个节点的左儿子小于父节点， 父节点又小于右儿子。 查询时间复杂度是O(log(N))。

当然为了维持O(log(N))的查询复杂度， 你就需要保持这棵树是平衡二叉树。 为了做这个保证， 更新的时间复杂度也是O(log(N))。

二叉树是搜索效率最高的， 但是实际上大多数的数据库存储却并不使用二叉树。 其原因是， 索引不止存在内存中， 还要写到磁盘上。

为了让一个查询尽量少地读磁盘， 就必须让查询过程访问尽量少的数据块。 那么， 我们就不应该
使用二叉树， 而是要使用“N叉”树。 这里， “N叉”树中的“N”取决于数据块的大小。

**以InnoDB的一个整数字段索引为例， 这个N差不多是1200。 这棵树高是4的时候， 就可以存1200的3次方个值， 这已经17亿了。** 考虑到树根的数据块总是在内存中的， 一个10亿行的表上一个整数字段的索引， 查找一个值最多只需要访问3次磁盘。

#### InnoDB 的索引模型

InnoDB使用了B+树索引模型， 所以数据都是存储在B+树中的。

每一个索引在InnoDB里面对应一棵B+树。

```
mysql> create table T(
id int primary key,
k int not null,
name varchar(16),
index (k))engine=InnoDB;
```
表中R1~R5的(ID,k)值分别为(100,1)、 (200,2)、 (300,3)、 (500,5)和(600,6)， 两棵树的示例示意图如下。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200121134238657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZWxsZXlMaXR0bGVoZXJv,size_16,color_FFFFFF,t_70)

从图中看出,<font color=blue>根据叶子节点的内容， 索引类型分为主键索引和非主键索引。</font>

<font color=blue>主键索引的叶子节点存的是整行数据。</font>在InnoDB里， **主键索引也被称为聚簇索引**（ clusteredindex） 。

<font color=blue>非主键索引的叶子节点内容是主键的值。</font> 在InnoDB里， 非主键索引也被称为二级索引（ secondaryindex） 。


##### 基于主键索引和普通索引的查询有什么区别？ (后者会回表)

- 如果语句是```select * from Twhere ID=500，``` 即主键查询方式， 则只需要搜索ID这棵B+树；
- 如果语句是```select * from Twhere k=5，``` 即普通索引查询方式， 则需要先搜索k索引树， 得到ID的值为500， 再到ID索引树搜索一次。 这个过程称为**回表。**

#### 索引维护

**性能角度:**
B+树为了维护索引有序性， 在插入新值的时候需要做必要的维护。 

以上面这个图为例， 

如果插入新的行ID值为700， 则只需要在R5的记录后面插入一个新记录。

如果新插入的ID值为400， 就相对麻烦了， 需要逻辑上挪动后面的数据， 空出位置。
 
更糟的情况是， 如果R5所在的数据页已经满了， 根据B+树的算法， 这时候需要申请一个新的数据页， 然后挪动部分数据过去。 这个过程称为**页分裂**。 

页分裂使 原本放在一个页的数据， 现在分到两个页中，整体空间利用率降低大约50%。

你可能在一些建表规范里面见到过类似的描述， 要求**建表语句里一定要有自增主键。**

自增主键是指自增列上定义的主键， 在建表语句中一般是这么定义的： NOTNULL PRIMARYKEY AUTO_INCREMENT。

自增主键的插入数据模式， 正符合了我们前面提到的递增插入的场景。 每次插入一条新记录， 都是追加操作， 都不涉及到挪动其他记录， 也不会触发叶子节点的分裂.

**存储空间的角度**

除了考虑性能外， 我们还可以从**存储空间的角度**来看。 假设你的表中确实有一个唯一字段， 比如
字符串类型的身份证号， 那**应该用身份证号做主键， 还是用自增字段做主键呢？**

由于每个非主键索引的叶子节点上都是主键的值。 如果用身份证号做主键， 那么每个二级索引的
叶子节点占用约20个字节， 而如果用整型做主键， 则只要4个字节， 如果是长整型（ bigint） 则是8个字节。

<font color=blue>显然， 主键长度越小， 普通索引的叶子节点就越小， 普通索引占用的空间也就越小 .</font>

从性能和存储空间方面考量， 自增主键往往是更合理的选择。

有没有什么场景适合用业务字段直接做主键的呢？ 还是有的。 比如， 有些业务的场景需求是这样的：

1. 只有一个索引；
2. 该索引必须是唯一索引。
你一定看出来了， 这就是典型的KV场景。

由于没有其他索引， 所以也就不用考虑其他索引的叶子节点大小的问题。

由于InnoDB是索引组织表， **一般情况下我会建议你创建一个自增主键， 这样非主键索引占用的空间最小。 **


### 05 深入浅出索引（ 下）

建表:
```
mysql> create table T (
ID int primary key,
k int NOT NULL DEFAULT 0,
s varchar(16) NOT NULL DEFAULT '',
index k(k))
engine=InnoDB;
insert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg');
```

如果我执行 ```select * from Twhere k between 3 and 5```， 需要执行几次树的搜索操作， 会扫描多少行？

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200121142924787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZWxsZXlMaXR0bGVoZXJv,size_16,color_FFFFFF,t_70)


现在， 我们一起来看看这条SQL查询语句的执行流程：

1. 在k索引树上找到k=3的记录， 取得 ID = 300；
2. 再到ID索引树查到ID=300对应的R3；
3. 在k索引树取下一个值k=5， 取得ID=500；
4. 再回到ID索引树查到ID=500对应的R4；
5. 在k索引树取下一个值k=6， 不满足条件， 循环结束。 <font color=red>为什么还会再在索引树上取k=6判断??? </font>

在这个过程中， 回到主键索引树搜索的过程， 我们称为回表。 可以看到， 这个查询过程读了k索引树的3条记录（ 步骤1、 3和5） ， 回表了两次（ 步骤2和4）


有没有可能经过索引优化， 避免回表过程呢？

#### 覆盖索引

如果执行的语句是select ID from Twhere k between 3 and 5， 这时只需要查ID的值， 而ID的值已经在k索引树上了， 因此可以直接提供查询结果， 不需要回表。 也就是说， 在这个查询里面，
**索引k已经“覆盖了”我们的查询需求， 我们称为覆盖索引。**

由于覆盖索引可以减少树的搜索次数， 显著提升查询性能， 所以使用覆盖索引是一个常用的性能优化手段。


基于上面覆盖索引的说明， 我们来讨论一个问题： **在一个市民信息表上， 是否有必要将身份证号和名字建立联合索引？**

我们知道， 身份证号是市民的唯一标识。 也就是说， 如果有根据身份证号查询市民信息的需求，
我们只要在身份证号字段上建立索引就够了。 而再建立一个（ 身份证号、 姓名） 的联合索引， 是
不是浪费空间？

如果现在有一个高频请求， **要根据市民的身份证号查询他的姓名， 这个联合索引就有意义了**。 它
可以在这个高频请求上用到覆盖索引， 不再需要回表查整行记录， 减少语句的执行时间。

#### 最左前缀原则

B+树这种索引结构， 可以利用索引的“最左前缀”， 来定位记录.

在建立联合索引的时候， 如何安排索 引内的字段顺序。

第一原则是， 如果通过调整顺序， 可以少维护一个索引， 那么这个顺序往往就是需要优先考虑采用的。

那么， 如果既有联合查询， 又有基于a、 b各自的查询呢？ 查询条件里面只有b的语句， 是无法使
用(a,b)这个联合索引的， 这时候你不得不维护另外一个索引， 也就是说你**需要同时维护(a,b)、(b) 这两个索引。**

这时候， 我们要考虑的原则就是空间了。 比如上面这个市民表的情况， name字段是比age字段
大的 ， 那我就建议你创建一个（ name,age)的联合索引和一个(age)的单字段索引。


#### 索引下推

你可能要问， 那些不符合最左前缀的部分， 会怎么样呢？

我们还是以市民表的联合索引（ name, age） 为例。 如果现在有一个需求： 检索出表中“名字第一
个字是张， 而且年龄是10岁的所有男孩”。 那么， SQL语句是这么写的：

```
mysql> select * from tuser where name like '张%' and age=10 and ismale=1;
```































