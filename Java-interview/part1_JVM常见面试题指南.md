### JVM 
#### 1.3 JVM 对象创建步骤流程是什么？
整体流程如下图所示：
![在这里插入图片描述](https://images.gitbook.cn/c3bd9860-3f65-11e9-b565-378070432200)
第 1 步：虚拟机遇到一个 new 指令，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用， 并且检查这个符号引用的类是否已经被加载&解析&初始化。

第 2 步：如果类已经被加载那么进行第 3 步； 如果没有进行加载， 那么就就需要先进行类的加载。

第 3 步：类加载检查通过之后， 接下来进行新生对象的内存分配。

第 4 步：对象生成需要的内存大小在类加载完成后便可完全确定，为对象分配空间等同于把一块确定大小的内存从 Java 堆中划分出来

第 5 步：内存大小的划分分为两种情况： 第一种情况：JVM 的内存是规整的， 所有的使用的内存都放到一边， 空闲的内存在另外一边， 中间放一个指针作为分界点的指示器。 那么这时候分配内存就比较简单， 只要讲指针向空闲空间那边挪动一段与对象大小相同的距离。 这种就是“指针碰撞”。

第二种情况：JVM 的内存不是规整的， 也就是说已使用的内存与未使用的内存相互交错。 这时候就没办法利用指正碰撞了。 这时候我们就需要维护一张表，用于记录那些内存可用， 在分配的时候从列表中找到一块足够大的空间划分给对象实例， 并更新到记录表上。

第 6 步：空间申请完成之后， JVM 需要将内存的空间都初始化为 0 值。如果使用 TLAB， 就可以在 TLAB 分配的时候就可以进行该工作。

第 7 步： JVM 对对象进行必要的设置。 例如， 这个对象是哪个类的实例、对象的哈希码、GC 年代等信息。

第 8 步：完成了上面的步骤之后 从 JVM 来看一个对象基本上完成了， 但从 Java 程序代码绝对来看， 对象创建才刚刚开始， 需要执行 < init > 方法， 按照程序中设定的初始化操作初始化， 这时候一个真正的程序对象生成了。

#### 1.4 垃圾回收算法有几种类型？ 他们对应的优缺点又是什么？
常见的垃圾回收算法有：
```
标记-清除算法、复制算法、标记-整理算法、分代收集算法
```

**标记-清除算法**
标记—清除算法包括两个阶段：“标记”和“清除”。 标记阶段：确定所有要回收的对象，并做标记。 清除阶段：将标记阶段确定不可用的对象清除。

缺点：
- 标记和清除的效率都不高。
- 会产生大量的碎片，而导致频繁的回收。

**复制算法**
内存分成大小相等的两块，每次使用其中一块，当垃圾回收的时候， 把存活的对象复制到另一块上，然后把这块内存整个清理掉。

缺点：
-需要浪费额外的内存作为复制区。
-当存活率较高时，复制算法效率会下降。

**标记-整理算法**
标记—整理算法不是把存活对象复制到另一块内存，而是把存活对象往内存的一端移动，然后直接回收边界以外的内存。

缺点： 算法复杂度大，执行步骤较多

**分代收集算法**
目前大部分 JVM 的垃圾收集器采用的算法。根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为新生代（ Young Generation 和老年代（ Tenured Generation ），永久代（ Permanet Generation ）。

老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。

#### 1.8 什么是双亲委派模式？有什么作用？
基本定义： 双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器没有找到所需的类时，子加载器才会尝试去加载该类。

**双亲委派机制:

- 当 AppClassLoader 加载一个 class 时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器 ExtClassLoader 去完成。

- 当 ExtClassLoader 加载一个 class 时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给 BootStrapClassLoader 去完成。

- 如果 BootStrapClassLoader 加载失败，会使用 ExtClassLoader 来尝试加载；

- 若 ExtClassLoader 也加载失败，则会使用 AppClassLoader 来加载，如果 AppClassLoader 也加载失败，则会报出异常 ClassNotFoundException。

**双亲委派作用：**

- 通过带有优先级的层级关可以避免类的重复加载；
- 保证 Java 程序安全稳定运行，Java 核心 API 定义类型不会被随意替换。


#### 2.2 JVM 数据运行区，哪些会造成 OOM 的情况？
除了数据运行区，其他区域均有可能造成 OOM 的情况。

堆溢出：java.lang.OutOfMemoryError: Java heap space
栈溢出：java.lang.StackOverflowError
永久代溢出：java.lang.OutOfMemoryError: PermGen space

#### 2.5 线上常用的 JVM 参数有哪些？
**数据区设置**
```
Xms：初始堆大小
Xmx：最大堆大小
Xss:Java 每个线程的Stack大小
XX:NewSize=n：设置年轻代大小
XX:NewRatio=n：设置年轻代和年老代的比值。如：为 3，表示年轻代与年老代比值为 1:3，年轻代占整个年轻代年老代和的 1/4。
XX：SurvivorRatio=n：年轻代中 Eden 区与两个 Survivor 区的比值。注意 Survivor 区有两个。如：3，表示 Eden：Survivor=3：2，一个 Survivor 区占整个年轻代的 1/5。
XX：MaxPermSize=n：设置持久代大小。
```

**收集器设置**
```
XX:+UseSerialGC：设置串行收集器
XX:+UseParallelGC:：设置并行收集器
XX:+UseParalledlOldGC：设置并行年老代收集器
XX:+UseConcMarkSweepGC：设置并发收集器
```
**GC日志打印设置**
```
XX:+PrintGC：打印 GC 的简要信息
XX:+PrintGCDetails：打印 GC 详细信息
XX:+PrintGCTimeStamps：输出 GC 的时间戳
```

#### 2.8 引起类加载操作的行为有哪些？
- 遇到 new、getstatic、putstatic 或 invokestatic 这四条字节码指令。
- 反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
- 子类初始化的时候，如果其父类还没初始化，则需先触发其父类的初始化。
- 虚拟机执行主类的时候（有 main（ string[] args））。
- JDK1.7 动态语言支持。


#### 2.9 介绍一下 JVM 提供的常用工具
jps：用来显示本地的 Java 进程，可以查看本地运行着几个 Java 程序，并显示他们的进程号。 命令格式：jps

jinfo：运行环境参数：Java System 属性和 JVM 命令行参数，Java class path 等信息。 命令格式：jinfo 进程 pid

jstat：监视虚拟机各种运行状态信息的命令行工具。 命令格式：jstat -gc 123 250 20

jstack：可以观察到 JVM 中当前所有线程的运行情况和线程当前状态。 命令格式：jstack 进程 pid

jmap：观察运行中的 JVM 物理内存的占用情况（如：产生哪些对象，及其数量）。 命令格式：jmap [option] pid


#### 2.10 Full GC 、 Major GC 、Minor GC 之间区别？
Minor GC： 从新生代空间（包括 Eden 和 Survivor 区域）回收内存被称为 Minor GC。

Major GC： 清理 Tenured 区，用于回收老年代，出现 Major GC 通常会出现至少一次 Minor GC。

Full GC： Full GC 是针对整个新生代、老年代、元空间（metaspace，java8 以上版本取代 perm gen）的全局范围的 GC。


#### 2.11 什么时候触发 Full GC ？
- 调用 System.gc 时，系统建议执行 Full GC，但是不必然执行。
- 老年代空间不足。
- 方法区空间不足。
- 通过 Minor GC 后进入老年代的平均大小大于老年代的可用内存。
- 由 Eden 区、survivor space1（From Space）区向 survivor space2（To Space）区复制时，对象大小大于 To Space 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。

#### 2.12 什么情况下会出现栈溢出
- 方法创建了一个很大的对象，如 List，Array。
- 是否产生了循环调用、死循环。
- 是否引用了较大的全局变量。

#### 2.13 说一下强引用、软引用、弱引用、虚引用以及他们之间和 gc 的关系
- 强引用：new 出的对象之类的引用，只要强引用还在，永远不会回收。
- 软引用：引用但非必须的对象，内存溢出异常之前，回收。
- 弱引用：非必须的对象，对象能生存到下一次垃圾收集发生之前。
- 虚引用：对生存时间无影响，在垃圾回收时得到通知。


### 实战
####  3.1 CPU 资源占用过高
- top 查看当前 CPU 情况，找到占用 CPU 过高的进程 PID=123。
- top -H -p123 找出两个 CPU 占用较高的线程，记录下来 PID=2345, 3456 转换为十六进制。
- jstack -l 123 > temp.txt 打印出当前进程的线程栈。
- 查找到对应于第二步的两个线程运行栈，分析代码。


#### 3.2 OOM 异常排查
- 使用 top 指令查询服务器系统状态。
- ps -aux|grep java 找出当前 Java 进程的 PID。
- jstat -gcutil pid interval 查看当前 GC 的状态。
- jmap -histo:live pid 可用统计存活对象的分布情况，从高到低查看占据内存最多的对象。
- jmap -dump:format=b,file= 文件名 [pid] 利用 Jmap dump。
- 使用性能分析工具对上一步 dump 出来的文件进行分析，工具有 MAT 等。












































