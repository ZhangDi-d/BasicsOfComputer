### JVM 
#### 1.3 JVM 对象创建步骤流程是什么？
整体流程如下图所示：
![在这里插入图片描述](https://images.gitbook.cn/c3bd9860-3f65-11e9-b565-378070432200)
第 1 步：虚拟机遇到一个 new 指令，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用， 并且检查这个符号引用的类是否已经被加载&解析&初始化。

第 2 步：如果类已经被加载那么进行第 3 步； 如果没有进行加载， 那么就就需要先进行类的加载。

第 3 步：类加载检查通过之后， 接下来进行新生对象的内存分配。

第 4 步：对象生成需要的内存大小在类加载完成后便可完全确定，为对象分配空间等同于把一块确定大小的内存从 Java 堆中划分出来

第 5 步：内存大小的划分分为两种情况： 第一种情况：JVM 的内存是规整的， 所有的使用的内存都放到一边， 空闲的内存在另外一边， 中间放一个指针作为分界点的指示器。 那么这时候分配内存就比较简单， 只要讲指针向空闲空间那边挪动一段与对象大小相同的距离。 这种就是“指针碰撞”。

第二种情况：JVM 的内存不是规整的， 也就是说已使用的内存与未使用的内存相互交错。 这时候就没办法利用指正碰撞了。 这时候我们就需要维护一张表，用于记录那些内存可用， 在分配的时候从列表中找到一块足够大的空间划分给对象实例， 并更新到记录表上。

第 6 步：空间申请完成之后， JVM 需要将内存的空间都初始化为 0 值。如果使用 TLAB， 就可以在 TLAB 分配的时候就可以进行该工作。

第 7 步： JVM 对对象进行必要的设置。 例如， 这个对象是哪个类的实例、对象的哈希码、GC 年代等信息。

第 8 步：完成了上面的步骤之后 从 JVM 来看一个对象基本上完成了， 但从 Java 程序代码绝对来看， 对象创建才刚刚开始， 需要执行 < init > 方法， 按照程序中设定的初始化操作初始化， 这时候一个真正的程序对象生成了。

#### 1.4 垃圾回收算法有几种类型？ 他们对应的优缺点又是什么？
常见的垃圾回收算法有：
```
标记-清除算法、复制算法、标记-整理算法、分代收集算法
```

**标记-清除算法**
标记—清除算法包括两个阶段：“标记”和“清除”。 标记阶段：确定所有要回收的对象，并做标记。 清除阶段：将标记阶段确定不可用的对象清除。

缺点：
- 标记和清除的效率都不高。
- 会产生大量的碎片，而导致频繁的回收。

**复制算法**
内存分成大小相等的两块，每次使用其中一块，当垃圾回收的时候， 把存活的对象复制到另一块上，然后把这块内存整个清理掉。

缺点：
-需要浪费额外的内存作为复制区。
-当存活率较高时，复制算法效率会下降。

**标记-整理算法**
标记—整理算法不是把存活对象复制到另一块内存，而是把存活对象往内存的一端移动，然后直接回收边界以外的内存。

缺点： 算法复杂度大，执行步骤较多

**分代收集算法**
目前大部分 JVM 的垃圾收集器采用的算法。根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为新生代（ Young Generation 和老年代（ Tenured Generation ），永久代（ Permanet Generation ）。

老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。

#### 1.8 什么是双亲委派模式？有什么作用？
基本定义： 双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器没有找到所需的类时，子加载器才会尝试去加载该类。

**双亲委派机制:

- 当 AppClassLoader 加载一个 class 时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器 ExtClassLoader 去完成。

- 当 ExtClassLoader 加载一个 class 时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给 BootStrapClassLoader 去完成。

- 如果 BootStrapClassLoader 加载失败，会使用 ExtClassLoader 来尝试加载；

- 若 ExtClassLoader 也加载失败，则会使用 AppClassLoader 来加载，如果 AppClassLoader 也加载失败，则会报出异常 ClassNotFoundException。

**双亲委派作用：**

- 通过带有优先级的层级关可以避免类的重复加载；
- 保证 Java 程序安全稳定运行，Java 核心 API 定义类型不会被随意替换。


#### 2.2 JVM 数据运行区，哪些会造成 OOM 的情况？
除了数据运行区，其他区域均有可能造成 OOM 的情况。

堆溢出：java.lang.OutOfMemoryError: Java heap space
栈溢出：java.lang.StackOverflowError
永久代溢出：java.lang.OutOfMemoryError: PermGen space

#### 2.5 线上常用的 JVM 参数有哪些？
**数据区设置**
```
Xms：初始堆大小
Xmx：最大堆大小
Xss:Java 每个线程的Stack大小
XX:NewSize=n：设置年轻代大小
XX:NewRatio=n：设置年轻代和年老代的比值。如：为 3，表示年轻代与年老代比值为 1:3，年轻代占整个年轻代年老代和的 1/4。
XX：SurvivorRatio=n：年轻代中 Eden 区与两个 Survivor 区的比值。注意 Survivor 区有两个。如：3，表示 Eden：Survivor=3：2，一个 Survivor 区占整个年轻代的 1/5。
XX：MaxPermSize=n：设置持久代大小。
```

**收集器设置**
```
XX:+UseSerialGC：设置串行收集器
XX:+UseParallelGC:：设置并行收集器
XX:+UseParalledlOldGC：设置并行年老代收集器
XX:+UseConcMarkSweepGC：设置并发收集器
```
**GC日志打印设置**
```
XX:+PrintGC：打印 GC 的简要信息
XX:+PrintGCDetails：打印 GC 详细信息
XX:+PrintGCTimeStamps：输出 GC 的时间戳
```










































